\documentclass[12pt]{article}
\usepackage{setspace}
\usepackage[margin=1in]{geometry}

\begin{document}

\doublespacing

%% Peter's section
% An  overview  of  your  complete  system  design,  using  block  diagrams,  pseudocode,  prose,  or  a  mixture  ofsome or all of these.  (This section should focus on the parts of the design that were completed by you, andshould not be a rewording of what is given in the lab manual.)
The music player software is designed in a modular pattern.
The most important sections of these are overviewed below.

The initialization code is run as soon as the board turns on.
It is responsible for running code to initialize the SD card and its FAT file
system, the audio codec, and the button and switch interrupts.
It also reads the SD card, and finds all files with a \texttt{.fat} file
extension, and saves their names and sectors in an array for use later.

Another module is the filesystem related code.
Much of this was provided as part of the lab starter code, although it was also
augmented to be able to treat a file as a stream.
This simplifies the interface exposed to the playback code, which consumes the
data from the file.
% TODO mention bugs in fs code

An interrupt handles the button press, which can change the current song,
playback mode, or playback state (ie: playing/stopped).
Note that because the interrupt handler can only block for a very short period
of time, the handler cannot actually read the next song name off the card.
The initialization process read all of the song files' information into an
array at the start.
The interrupt handler just loops through this array.

The handler propagates changes to the state, mode, or currently selected file
back to the main loop by updating a struct which the interrupt handler and main
loop both have a reference to.
The main loop is responsible for updating the LCD display, because updating it
in the interrupt handler would block for too long.
Primarily, it busy waits until it is signalled to start playing music.

When the playback state changes to start playing a song, the file of whichever
song is currently selected is opened, and a file stream is created.
The audio playback method is passed the filestream, along with a playback mode,
and a reference to the same struct used by the interrupt handler.
The playback method periodically checks the struct, and stops if the playback
mode has changed.
This is used by the interrupt handler to abort playback mid-way through the audio
file.

% A  discussion  of  the  issues  associated  with  one  aspect  of  your  hardware  design  or  the  software  interfacingpart  of  your  design,  for  example,  the  choice  of  interrupt  priorities  or  issues  with  respect  to  interfacing  tothe buttons, switches or LCD display.
% An indication of one hardware or software interfacing design decision you made given the above issues, andat least one alternative which you discarded.


%% Justin's section
% Hmm.... I just realized that maybe I'm not supposed to do all of these?

% A description of the testing and debugging strategy you used for one part of your hardware or software interfacing design and at least one alternative strategy that you discarded. Indicate any intermediate stages used in your design.
For debugging, we initially just used printf. This technique was quite useful
for determining if a section of code was running at all, i.e. to make sure our
init code was running properly. This came in handy when the board we were
initially using was fried- it would run our code, but get stuck in the SD card
driver initialization, because a input never went low. Quickly isolating the
line that was causing the issue allowed us to switch to another computer and
continue developing the lab. However, this didn't work very effectively when
code was running very quickly- for example, when our sample playing code was
not stopping at the end of a file properly, and would just keep playing
beyond that. Printing inside our sample playing loop would have made the code
run so slowly that we would not have been able to debug it effectively.
Instead, we started displaying the loop counter values on the LEDs. This worked
fairly well, but it was difficult to figure out the value quickly (important
in this case, as the values were changing quickly), and the range of values
that could be displayed was not very big. For these reasons, we eventually
transitioned to using the seven-segment to show values we cared about, in
hexadecimal.

% A discussion of the issues that impacted on the audio playback performance for each of the playback modes.
Normal, reverse, and slow modes played smoothly immediately without additional
code or complexities required, since we had followed the suggestions in the
lab manual of reading the cluster chain beforehand. Delay mode, however,
presented some significant challanges.

% A discussion of the issues associated with writing effcient software so as to meet the performance requirements associated with the system.

% An indication of one software design decision you made given the above two performance issues, and at least one alternative which you discarded.

% A description of the testing and debugging strategy you used for one part of your  software with regards to the audio playback, and at least one alternative strategy that you discarded. Indicate any intermediate stages used in your software design.
The first strategy we tried was just randomly changing things. Unsurprisingly,
this did not work particularilly well. Debugging issues for audio playback
was not easy to do with our more traditional debugging methods, because often
the problem would not be a logical error in the program, but rather just be
that we were using a technique which was too slow. In order to pinpoint issues
that were contributing to potential slowness, we wrote a stopwatch which used
the 10us onboard timer to allow timing of code sections. This allowed us to
figure out which sections were taking the most time, optimize those sections,
and provided us a way to know if our changes were actually improving the speed
of the relevent code sections- because improvements to the code's speed did
not necesarilly lead to perceptable improvements in audio.

% A  brief  discussion  of  a  possible  future  extension  to  the  lab.   Given  more  choice  for  a  final  project  (andpossibly 4-5 weeks in which to do it) and the same equipment, what would you have rather done?
There were a few things I would have liked to try as possible future extensions
to this lab:
\begin{enumerate}
\item Show the progress of the current song on the LCD display, or on the LEDs.
\item Make 2x speed actually play the audio properly. This could be pretty
	challanging, but optimizing the raw sd card block reading code could
	probably get pretty far in this direction. We could also increase the
	clock speed of the processor used on the board, or introduce some special-
	purpose instructions for reading the sd card data to allow it to complete
	in fewer clock cycles.
\item Make an equilizer visualization, either on the LCD or the LEDs.
\end{enumerate}


%% Reflection
%% TODO!!!!!!!!

\end{document}
