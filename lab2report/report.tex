\documentclass[12pt]{article}
\usepackage{setspace}
\usepackage[margin=1in]{geometry}

\begin{document}

\doublespacing

The music player software is designed in a modular pattern.
The most important sections of these are overviewed below.

The initialization code is run as soon as the board turns on.
It is responsible for running code to initialize the SD card and its FAT file
system, the audio codec, and the button and switch interrupts.
It also reads the SD card, and finds all files with a \texttt{.fat} file
extension, and saves their names and sectors in an array for use later.

Another module is the filesystem related code.
Much of this was provided as part of the lab starter code, although it was also
augmented to be able to treat a file as a stream.
This simplifies the interface exposed to the playback code, which consumes the
data from the file.
% TODO mention bugs in fs code

An interrupt handles the button press, which can change the current song,
playback mode, or playback state (ie: playing/stopped).
Note that because the interrupt handler can only block for a very short period
of time, the handler cannot actually read the next song name off the card.
The initialization process read all of the song files' information into an
array at the start.
The interrupt handler just loops through this array.

The handler propagates changes to the state, mode, or currently selected file
back to the main loop by updating a struct which the interrupt handler and main
loop both have a reference to.
The main loop is responsible for updating the LCD display, because updating it
in the interrupt handler would block for too long.
Primarily, it busy waits until it is signalled to start playing music.

When the playback state changes to start playing a song, the file of whichever
song is currently selected is opened, and a file stream is created.
The audio playback method is passed the filestream, along with a playback mode,
and a reference to the same struct used by the interrupt handler.
The playback method periodically checks the struct, and stops if the playback
mode has changed.
This is used by the interrupt handler to abort playback mid-way through the audio
file.

%% Justin's section
% A description of the testing and debugging strategy you used for one part of your hardware or software interfacing design and at least one alternative strategy that you discarded. Indicate any intermediate stages used in your design.
For debugging, we initially just used printf. This technique was quite useful
for determining if a section of code was running at all, i.e. to make sure our
init code was running properly. This came in handy when the board we were
initially using was fried- it would run our code, but get stuck in the SD card
driver initialization, because a input never went low. Quickly isolating the
line that was causing the issue allowed us to switch to another computer and
continue developing the lab. However, this didn't work very effectively when
code was running very quickly- for example, when our sample playing code was
not stopping at the end of a file properly, and would just keep playing
beyond that. Printing inside our sample playing loop would have made the code
run so slowly that we would not have been able to debug it effectively.
Instead, we started displaying the loop counter values on the LEDs. This worked
fairly well, but it was difficult to figure out the value quickly (important
in this case, as the values were changing quickly), and the range of values
that could be displayed was not very big. For these reasons, we eventually
transitioned to using the seven-segment to show values we cared about, in
hexadecimal.

% A discussion of the issues that impacted on the audio playback performance for each of the playback modes.
Normal, reverse, and slow modes played smoothly immediately without additional
code or complexities required, since we had followed the suggestions in the
lab manual of reading the cluster chain beforehand. Delay mode, however,
presented some significant challanges.

% A discussion of the issues associated with writing effcient software so as to meet the performance requirements associated with the system.

% An indication of one software design decision you made given the above two performance issues, and at least one alternative which you discarded.

%% Reflection
%% TODO!!!!!!!!

\end{document}
